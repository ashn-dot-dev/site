#!/usr/bin/env mf

let text = type {
    .init = function(txt) {
        return new text {
            "text" = txt,
        };
    },
    .string = function(value) {
        return value.text;
    },
};

let tag = type {
    .init = function(attributes, children) {
        return new tag {
            .attributes = attributes,
            .children = children,
        };
    },
    .string = function(value) {
        error "unimplemented for type " + typename(value);
    },
    .inner = function(self) {
        return "".join(self.*.children
            .iterator()
            .transform(function(child) { return string(child); })
            .collect());
    },
};


let tag_dialogue = type Map::union(tag, {
    .init = function(attributes, children) {
        return new tag_dialogue tag::init(attributes, children);
    },
    .string = function(value) {
        let character = value.attributes["character"].to_lower();
        let portrait = "default.png";
        if value.attributes.contains("portrait") {
            portrait = value.attributes["portrait"].to_lower();
        }
        return $```
<div class="dialogue-container" dialogue-character="{character}">
    <div class="dialogue-portrait">
        <img src="/characters/{character}/{portrait}" alt="{character} portrait"/>
    </div>
    <div class="dialogue-content">
        <div class="dialogue-name">{character.to_title()}</div>
        <div>{value.inner().trim()}</div>
    </div>
</div>```.trim();
    }
});

let tag_image = type Map::union(tag, {
    .init = function(attributes, children) {
        return new tag_image tag::init(attributes, children);
    },
    .string = function(value) {
        let attrs = [];
        for k, v in value.attributes {
            attrs.push($`{string(k)}="{string(v)}"`);
        }
        let alt = html::escape(value.inner().trim()).replace("\n", " ");
        return $`<img {" ".join(attrs)} alt="{alt}"/>`;
    }
});

let tag_wave = type Map::union(tag, {
    .init = function(attributes, children) {
        return new tag_wave tag::init(attributes, children);
    },
    .string = function(value) {
        let text = value.inner();
        let characters = [];
        # TODO: Need to iterate over characters grapheme-cluster, not by byte.
        for i in range(0, text.count()) {
            let character = text.slice(i, i+1);
            let delay = i * 0.15; # 150 ms delay per character
            characters.push(
                $`<span class="wave-character" style="animation-delay: {delay}s;">{html::escape(character)}</span>`);
        }

        return $`<span class="wave-container">{"".join(characters)}</span>`;
    }
});

let TAG_REGISTRY = map{
    "Dialogue": tag_dialogue,
    "Image": tag_image,
    "Wave": tag_wave,
};

let source_location = type {
    .init = function(file, line) {
        return new source_location {
            .file = file,
            .line = line,
        };
    },
};

let parse_error = type {
    .init = function(location, message) {
        return new parse_error {
            .location = location,
            .message = message,
        };
    },
};

let token_kind = type {
    .EOF = "end-of-file",
    .TEXT = "text",
    .OPENING_TAG = "opening tag",
    .CLOSING_TAG = "closing tag",
};

let token = type {
    .init = function(location, kind, text) {
        return new token {
            .location = location,
            .kind = kind,
            .text = text,
        };
    },
};

# \{{
let match_escaped_lbraces = function(text) {
    return text =~ `^\\\{\{`;
};
# \}}
let match_escaped_rbraces = function(text) {
    return text =~ `^\\\{\{`;
};
# attribute-a attribute-b="value-b" attribute-c
let match_attributes = function(text) {
    return text =~ `^(\w+)(?:="([^"]*)")?`;
};
# attribute="value"
let match_attribute = function(text) {
    return text =~ `^(\w+)(="([^"]*)")?`;
};
# {{TagName attribute-a attribute-b="value-b" attribute-c}}
let match_opening_tag = function(text) {
    return text =~ `^\{\{([A-Za-z]\w*)(?:\s+([^}]*?))?\}\}`;
};
# {{/TagName}}
let match_closing_tag = function(text) {
    return text =~ `^\{\{/([A-Za-z]\w*)\}\}`;
};

let lexer = type {
    .init = function(source, location) {
        return new lexer {
            .source = source,
            .location = location,
            .position = 0,
        };
    },
    .next_token = function(self) {
        let start = self.*.position;
        let location = self.*.location;

        if self.*._is_eof() {
            return token::init(location, token_kind::EOF, "");
        }

        if match_opening_tag(self.*._remaining()) {
            self.*.position = self.*.position + re::group(0).count();
            return token::init(location, token_kind::OPENING_TAG, re::group(0));
        }

        if match_closing_tag(self.*._remaining()) {
            self.*.position = self.*.position + re::group(0).count();
            return token::init(location, token_kind::CLOSING_TAG, re::group(0));
        }

        let text = "";
        while true {
            if self.*._is_eof() {
                break;
            }

            if match_opening_tag(self.*._remaining()) or match_closing_tag(self.*._remaining()) {
                break;
            }

            if match_escaped_lbraces(self.*._remaining()) {
                text = text + "{{";
                self.*.position = self.*.position + re::group(0).count();
                continue;
            }

            if match_escaped_rbraces(self.*._remaining()) {
                text = text + "}}";
                self.*.position = self.*.position + re::group(0).count();
                continue;
            }

            text = text + self.*._remaining().slice(0, 1);
            if text.ends_with("\n") {
                self.*.location.line = self.*.location.line + 1;
            }
            self.*.position = self.*.position + 1;
        }
        let token = token::init(location, token_kind::TEXT, text);
        return token;
    },
    ._is_eof = function(self) {
        return self.*.position >= self.*.source.count();
    },
    ._remaining = function(self) {
        return self.*.source.slice(self.*.position, self.*.source.count());
    },
};

let parser = type {
    .init = function(lexer) {
        let current = lexer.next_token();
        return new parser {
            .lexer = lexer,
            .current = current,
        };
    },
    .parse = function(self) {
        let nodes = [];
        while self.*.current.kind != token_kind::EOF {
            let node = self.*._parse_node();
            nodes.push(node);
        }
        return nodes;
    },
    ._parse_node = function(self) {
        if self.*.current.kind == token_kind::TEXT {
            return self.*._parse_text();
        }

        if self.*.current.kind == token_kind::OPENING_TAG {
            return self.*._parse_tag();
        }

        error parse_error::init(
            self.*.current.location,
            "expected tag or text, found " + repr(self.*.current.kind));
    },
    ._parse_text = function(self) {
        return text::init(self.*._expect_current(token_kind::TEXT).text);
    },
    ._parse_tag = function(self) {
        let opening_tag = self.*._expect_current(token_kind::OPENING_TAG);
        assert(match_opening_tag(opening_tag.text));
        let name = re::group(1);

        let attributes = map{};
        if re::group(2) != null {
            let text = re::group(2).trim();
            while match_attribute(text) {
                let k = re::group(1);
                let v = re::group(3);
                if v == null {
                    v = "";
                }
                attributes[k] = v;
                text = text.slice(re::group(0).count(), text.count()).trim();
            }
        }

        let children = [];
        while not self.*._check_current(token_kind::CLOSING_TAG) {
            children.push(self.*._parse_node());
        }

        let closing_tag = self.*._expect_current(token_kind::CLOSING_TAG);
        assert(match_closing_tag(closing_tag.text));
        if re::group(1) != name {
            error parse_error::init(
                self.*.current.location,
                "expected " +
                token_kind::CLOSING_TAG +
                " `" +
                name +
                "`, found `" +
                re::group(1) +
                "`"
            );
        }

        return TAG_REGISTRY[name]::init(attributes, children);
    },
    ._advance = function(self) {
        self.*.current = self.*.lexer.next_token();
    },
    ._check_current = function(self, kind) {
        return self.*.current.kind == kind;
    },
    ._expect_current = function(self, kind) {
        let current = self.*.current;
        if current.kind != kind {
            error parse_error::init(current.location, "expected " + repr(kind) + ", found " + repr(current));
        }
        self.*._advance();
        return current;
    },
};

let file = null;
let source = null;
if argv.count() == 1 {
    file = "<stdin>";
    source = input();
}
elif argv.count() == 2 {
    file = argv[1];
    source = fs::read(file);
}
else {
    error "multiple input files specified " + repr(argv.slice(1, argv.count()));
}

let location = source_location::init(file, 1);
let nodes = parser::init(lexer::init(source, location)).parse();
for node in nodes {
    #println($`{typename(node)}: {node}`);
    print(node);
}
