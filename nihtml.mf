#!/usr/bin/env -S mf --
#
# Debug performance:
#   term-clear && ./nihtml.mf --debug src/nihtml.md 2>&1 | ts-absolute

let is_debug = false;
let debugln = function(x) {
    if not is_debug {
        return;
    }
    eprintln($"[DEBUG] {x}");
};

let text = type {
    .init = function(txt) {
        return new text {
            "text" = txt,
        };
    },
    .into_string = function(self) {
        return self.text;
    },
};

let tag = type {
    .init = function(attributes, children) {
        return new tag {
            .attributes = attributes,
            .children = children,
        };
    },
    .into_string = function(self) {
        error $"unimplemented for type {typename(self.*)}";
    },
    .inner = function(self) {
        return "".join(self.children
            .iterator()
            .transform(function(child) { return string::init(child); })
            .into_vector());
    },
};

let tag_dialogue = type extends(tag, {
    .init = function(attributes, children) {
        return new tag_dialogue tag::init(attributes, children);
    },
    .into_string = function(self) {
        let character = self.attributes["character"].to_lower();
        let portrait = "default.png";
        if self.attributes.contains("portrait") {
            portrait = self.attributes["portrait"].to_lower();
        }
        return $```
<div class="dialogue-container" dialogue-character="{character}">
    <div class="dialogue-portrait">
        <img src="/characters/{character}/{portrait}" alt="{character} portrait"/>
    </div>
    <div class="dialogue-content">
        <div class="dialogue-name">{character.to_title()}</div>
        <div>{self.inner().trim()}</div>
    </div>
</div>```.trim();
    }
});

let tag_image = type extends(tag, {
    .init = function(attributes, children) {
        return new tag_image tag::init(attributes, children);
    },
    .into_string = function(self) {
        let attrs = [];
        for k, v in self.attributes {
            attrs.push($`{string::init(k)}="{string::init(v)}"`);
        }
        let alt = html::escape(self.inner().trim()).replace("\n", " ");
        return $`<img {" ".join(attrs)} alt="{alt}"/>`;
    }
});

let tag_wave = type extends(tag, {
    .init = function(attributes, children) {
        return new tag_wave tag::init(attributes, children);
    },
    .into_string = function(self) {
        let text = self.inner();
        let characters = [];
        # TODO: Need to iterate over characters by grapheme-cluster, not by rune.
        let runes = text.runes();
        for i in range(0, runes.count()) {
            let character = runes[i];
            if character == " " or character == "\n" {
                characters.push(" ");
                continue;
            }

            let delay = i * 0.15; # 150 ms delay per character
            characters.push(
                $`<span class="wave-character" style="animation-delay: {delay}s;">{html::escape(character)}</span>`
            );
        }

        return $`<span class="wave-container">{"".join(characters)}</span>`;
    }
});

let TAG_REGISTRY = {
    "Dialogue": tag_dialogue,
    "Image": tag_image,
    "Wave": tag_wave,
};

let source_location = type {
    .init = function(file, line) {
        return new source_location {
            .file = file,
            .line = line,
        };
    },
};

let parse_error = type {
    .init = function(location, message) {
        return new parse_error {
            .location = location,
            .message = message,
        };
    },
};

let token_kind = type {
    .EOF = "end-of-file",
    .TEXT = "text",
    .OPENING_TAG = "opening tag",
    .CLOSING_TAG = "closing tag",
};

let token = type {
    .init = function(location, kind, text) {
        return new token {
            .location = location,
            .kind = kind,
            .text = text,
        };
    },
};

# \{{
let re_escaped_lbraces = r`^\\\{\{`;
# \}}
let re_escaped_rbraces = r`^\\\}\}`;
# attribute-a attribute-b="value-b" attribute-c
let re_attributes = r`^(\w+)(?:="([^"]*)")?`;
# attribute="value"
let re_attribute = r`^(\w+)(="([^"]*)")?`;
# {{TagName attribute-a attribute-b="value-b" attribute-c}}
let re_opening_tag = r`^\{\{([A-Za-z]\w*)(?:\s+([^}]*?))?\}\}`;
# {{/TagName}}
let re_closing_tag = r`^\{\{/([A-Za-z]\w*)\}\}`;
# Matches text that doesn't start with \{{, \}}, or {{
let re_nominal_text = r`^([^\\{]|\\[^{}]|{[^{])+`;

let lexer = type {
    .init = function(source, location) {
        return new lexer {
            .source = source,
            .location = location,
            .position = 0,
        };
    },
    .next_token = function(self) {
        let start = self.position;
        let location = self.location;
        debugln($"{lexer.next_token}: lexing token@{location}");

        if self._is_eof() {
            debugln($"{lexer.next_token}: lexing {token_kind::EOF} token@{location}");
            return token::init(location, token_kind::EOF, "");
        }

        if self._remaining() =~ re_opening_tag {
            debugln($"{lexer.next_token}: lexing {token_kind::OPENING_TAG} token@{location}");
            self.position = self.position + re::group(0).count();
            return token::init(location, token_kind::OPENING_TAG, re::group(0));
        }

        if self._remaining() =~ re_closing_tag {
            debugln($"{lexer.next_token}: lexing {token_kind::CLOSING_TAG} token@{location}");
            self.position = self.position + re::group(0).count();
            return token::init(location, token_kind::CLOSING_TAG, re::group(0));
        }

        let text = "";
        while true {
            if self._is_eof() {
                break;
            }

            if self._remaining() =~ re_opening_tag or self._remaining() =~ re_closing_tag {
                break;
            }

            if self._remaining() =~ re_nominal_text {
                debugln($"{lexer.next_token}: lexing {token_kind::TEXT} chunk@{self.location}");
                let chunk = re::group(0);
                text = text + chunk;
                self.location.line = self.location.line + (chunk.split("\n").count() - 1);
                self.position = self.position + chunk.count();
                continue;
            }

            if self._remaining() =~ re_escaped_lbraces {
                debugln($"{lexer.next_token}: lexing {token_kind::TEXT} lbrace@{self.location}");
                text = text + "{{";
                self.position = self.position + re::group(0).count();
                continue;
            }

            if self._remaining() =~ re_escaped_rbraces {
                debugln($"{lexer.next_token}: lexing {token_kind::TEXT} rbrace@{self.location}");
                text = text + "}}";
                self.position = self.position + re::group(0).count();
                continue;
            }

            debugln($"{lexer.next_token}: lexing {token_kind::TEXT} byte@{self.location}");
            text = text + self._remaining().slice(0, 1);
            if text.ends_with("\n") {
                self.location.line = self.location.line + 1;
            }
            self.position = self.position + 1;
        }
        let token = token::init(location, token_kind::TEXT, text);
        return token;
    },
    ._is_eof = function(self) {
        return self.position >= self.source.count();
    },
    ._remaining = function(self) {
        return self.source.slice(self.position, self.source.count());
    },
};

let parser = type {
    .init = function(lexer) {
        let current = lexer.next_token();
        return new parser {
            .lexer = lexer,
            .current = current,
        };
    },
    .parse = function(self) {
        let nodes = [];
        while self.current.kind != token_kind::EOF {
            let current = self.current;
            debugln($"{parser.parse}: parsing node with current token {current.kind}@{current.location}");
            let node = self._parse_node();
            debugln($"{parser.parse}: parsed node {typename(node)}@{current.location}");
            nodes.push(node);
        }
        return nodes;
    },
    ._parse_node = function(self) {
        if self.current.kind == token_kind::TEXT {
            return self._parse_text();
        }

        if self.current.kind == token_kind::OPENING_TAG {
            return self._parse_tag();
        }

        error parse_error::init(
            self.current.location,
            "expected tag or text, found " + repr(self.current.kind));
    },
    ._parse_text = function(self) {
        return text::init(self._expect_current(token_kind::TEXT).text);
    },
    ._parse_tag = function(self) {
        let opening_tag = self._expect_current(token_kind::OPENING_TAG);
        assert(opening_tag.text =~ re_opening_tag);
        let name = re::group(1);

        let attributes = Map{};
        if re::group(2) != null {
            let text = re::group(2).trim();
            while text =~ re_attribute {
                let k = re::group(1);
                let v = re::group(3);
                if v == null {
                    v = "";
                }
                attributes[k] = v;
                text = text.slice(re::group(0).count(), text.count()).trim();
            }
        }

        let children = [];
        while not self._check_current(token_kind::CLOSING_TAG) {
            children.push(self._parse_node());
        }

        let closing_tag = self._expect_current(token_kind::CLOSING_TAG);
        assert(closing_tag.text =~ re_closing_tag);
        if re::group(1) != name {
            error parse_error::init(
                self.current.location,
                "expected " +
                token_kind::CLOSING_TAG +
                " `" +
                name +
                "`, found `" +
                re::group(1) +
                "`"
            );
        }

        return TAG_REGISTRY[name]::init(attributes, children);
    },
    ._advance = function(self) {
        self.current = self.lexer.next_token();
    },
    ._check_current = function(self, kind) {
        return self.current.kind == kind;
    },
    ._expect_current = function(self, kind) {
        let current = self.current;
        if current.kind != kind {
            error parse_error::init(current.location, $"expected {repr(kind)}, found {repr(current)}");
        }
        self._advance();
        return current;
    },
};

let help = function(writeln) {
    writeln($```
usage: {argv[0]} [file]

Not Invented Here Text Markup Language

positional arguments:
  file          Text file to process (defaults to stdin).

optional arguments:
  -d, --debug   Write diagnostic debug information to stderr.
  -h, --help    Display this help text and exit.
    ```.trim());
};

let file = null;
let source = null;
let argi = 1;
while argi < argv.count() {
    if argv[argi] =~ r`^-+d(ebug)?$` {
        is_debug = true;
        argi = argi + 1;
        continue;
    }
    if argv[argi] =~ r`^-+h(elp)?$` {
        help(println);
        exit(0);
    }

    if file != null and source != null {
        error $"multiple input files, {file} and {argv[argi]}";
    }
    file = argv[argi];
    source = fs::read(file);
    argi = argi + 1;
}
if file == null and source == null {
    file = "<stdin>";
    source = input();
}

let location = source_location::init(file, 1);
let nodes = parser::init(lexer::init(source, location)).parse();
for node in nodes {
    #debugln($`{typename(node)}: {node}`);
    print(node);
}
